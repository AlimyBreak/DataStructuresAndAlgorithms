+ [慕课网连接](https://coding.imooc.com/class/chapter/71.html)
+ 程序员的内功修炼算法数据结构

# 三.高级排序问题
+ O(n<sup>2</sup>) ---------> O(nlogn)
+ 
+ 归并排序
+ 快速排序
+ 衍生问题
## 1.归并排序(merge sort)
+ 基础思路:二分法(使用递归实现自顶而下的归并排序)
+ 首先把N分成两个 N/2的数组,然后分别将这两个数组进行排序再归并
+ 每个N/2数组又可以拆分成两个(1-->2--->4),分半---排序---归并
+ 过程分析：8个元素分成3级,(log<sub>2</sub>n,若不是整数则上取整,)
+ 两个已经排序好的数组如何进行重排了？----需要临时空间辅助
+ 归并过程:开辟等长度的临时空间的三个指针位置辅助进行归并,[left,right] middle 元素 辅助条件
+ 归并排序分为二分过程和归并过程,其中排序操作实在归并过程中完成.
+ 归并排序算法优缺点:时间复杂度降低但空间复杂度升高,堆栈开销还受到归并递归深度影响
+ 小技巧,加法溢出怎么办: (a+b)/2 ----->   b + (a-b)/2
+ 50000个无序整数排序效果
+ insertionSort : 4.531 s
+ bubbleSort : 10.438 s
+ mergeSort : 0.016 s
+ 50000个接近有序整数排序效果(100次随机交换)
+ insertionSort : 0.015 s
+ bubbleSort : 3.657 s
+ mergeSort : 0.016 s
+ 显然,在接近有序的数组排序时,插入排序比归并排序效果还要好!
+ 对应近乎有序的数组添加优化代码后(交换100次):
+ insertionSort : 0.016 s
+ bubbleSort : 3.766 s
+ mergeSort : 0.015 s
### 对于递归终止条件的优化
+ 我们目前采用自然终止条件(l>=right),但实际上在分块分得很小时就可以使用[插入排序]来代替
+ n比较小时,插入排序的效率高于归并排序.
+ 测试结果:
+ insertionSort : 0.016 s
+ bubbleSort : 3.672 s
+ mergeSort : [0] 

## 2.自底向上的归并排序算法
### 自底向上,只要迭代
+开 始以间隔为1的进行归并，也就是说，第一个元素跟第二个进行归并。第三个与第四个进行归并；
+ 然后，再以间隔为2的进行归并，1-4进行归并，5-8进行归并；
+ 再以2*2的间隔，同理，知道2*k超过数组长度为止。
+ ----------------------------------------------------
+ 优化思路:
+ a.找出不需要进行归并操作的条件if(arr[mid]<=arr[mid+1])
+ b.对小长度数组使用插入排序
+ ----------------------------------------------------
+ 自顶而下和自底而下的归并排序实际性能差不多,在统计意义上来讲,递归法会快一些(原因?)
+ 其他应用:自底而上的归并算法能很好的对链表进行排序,选作作业(Todo).
+ ----------------------------------------------------
## 3.快速排序(quick sort)
+ 被誉为20世界最伟大的算法之一
+ ----------------------------------------------------
+ 基础思路:
+ a. 选定一个元素v,把他放在他应该在的地方,他的左边都小于他,他的右边都大于他;(Partition)
+ b. 然后在对左边和右边分别进行排序.
+ ------- Partition 过程 -------------------
+ A. 如何选定那个元素v(一般选最left)
+ B. 选定以后,开始遍历数组并对数组进行整理,整理结果前一部分小于v,后面一部分都大于等于v,并用j来记录分界点,新判断一个元素时,若该元素大于等于v,则不动;
+ 若该元素小于v,则该元素和j对应的元素进行交换,j自加,然后再考察下一个元素.
+ C. 遍历完毕后,把第0个l和j指向的内容进行交换即可.
+ D. 然后递归对前一半和后一半进行快速排序
+ ------------------------------------------
+ 测试效果:(100*10000个无序数据的排序)
+ mergeSort_Bottom2Top : 0.329 s
+ mergeSort : 0.265 s
+ quickSort : 0.266 s
+ ----------------------------------------------------
+ 依然存在的问题及改进方向(两个优化):
+ a. 高级的排序方法在底层都可以使用插入排序来代替(已经解决)
+ b. 对于近乎有序的数组,会有陷阱(太慢了)
+ c. 归并排序能够保证每次都是平均划分数据,但快速排序不能保证这一点
+ d. 快速排序的递归树不稳定(递归部分和递归深度),在最坏的情况下将退化成O(n<sup>2</sup>)
+ e. 如何解决:最好选一个组内的平均值,那只能随机的选择一个数来做,此时的数学期望为nlogn
+ 在优化前(疑似递归递炸了,这次的测试数据只有1000组,交换了10次):
+ mergeSort_Bottom2Top : 0 s
+ mergeSort : 0 s
+ quickSort : 0.078 s
+ 在优化后(100万个数据,这下递归不会递炸了):
+ mergeSort_Bottom2Top : 0.016 s
+ mergeSort : 0.015 s
+ quickSort : 0.188 s
+ f.依然存在的问题:
+ 生成大量相同的数据 generateRandomArray(1000,0,10)
+ 测试结果(测试100000个点)
+ mergeSort_Bottom2Top : 0.016 s
+ mergeSort : 0.016 s
+ quickSort : 1.515 s
+ h.分析: element == v 时怎么办? 包含大量重复value时,partition操作会把数组分为极度不平衡的两部分,极端情况下,模型退化成O(n<sup>2</sup>)
+ 思路1:重写partition函数,把小于等于v和大于等于v放在数组的两端,那等于v的元素就分散在两边了。
+ 测试结果(generateRandomArray(100000,0,10)):
+ mergeSort_Bottom2Top : 0.016 s
+ mergeSort : 0.031 s
+ quickSort : 1.499 s
+ quickSort2 : 0.016 s
+ 在其他的测试用例下效率也表现很好
+ 思路2: 3 ways( <v  == v  >v),在==v的部分根本不用管理,只需要排<v 和 >v的两部分
+ 测试效果(generateRandomArray(100000,0,10))
+ mergeSort_Bottom2Top : 0.031 s
+ mergeSort : 0.016 s
+ quickSort : 1.5 s
+ quickSort2 : 0.015 s
+ quickSort3 : 0 s

## 4.归并排序和快速排序的衍生问题
+ 归并和快速都使用了分治算法(分而治之,就是将原问题,分割成同等结构的子问题/,然后将子问题逐一解决,原问题也就得到了解决)
+ 代表了分治算法的两类基本思想:归并,主要考虑如何归并;快速排序,主要考虑怎么分.
+ 衍生的问题:
+ a.求逆序对(衡量数据的混乱程度)
+ 已经排好的数组-->逆序对为0,完全逆序的数组--->逆序对为C<sub>n</sub><sup>2</sup>.
+ 方法一:暴力解法,考察每一个数对.算法复杂度:O(n<sup>2</sup>).
+ 方法二:merge sort的思路来求逆序对的个数, 算法复杂度:O(nlogn)
+ 主要考虑归并过程,在排序过程中对逆序对数进行操作.(todo)
+ b.取出数组中第n大的元素,取出数组中的最大值和最小值
+ 方法一:排序O(nlogn)
+ 方法二:用快速排序的思路求数组中的第n大元素,期望要求是O(n)
+ 快速排序的特点:排好v后,v所在即最终所在,只需要递归考察v所在前后v所在后的那一块了(todo,)。