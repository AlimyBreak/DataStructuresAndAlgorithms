+ [慕课网连接](https://coding.imooc.com/class/chapter/71.html)
+ 程序员的内功修炼算法数据结构

# 索引堆(Index Heap)
## 1.普通堆的使用局限

+ 若有排序对象很复杂，那交换本身就是消耗巨大的；
+ 元素的位置在数组中的位置将改变，那索引数据和通过索引改变起来就会非常困难。

***

## 2.最大索引堆(Index Max Heap)

+ 将数据和索引分开存储(Index,data)
+ 构建堆的过程只有索引发生交换
+ 要对堆中的数据进行修改，修改对应的数据，然后调整堆即可。

### 2.1 可以实现的特别操作

+ 获得堆顶元素的索引
+ 通过数组索引获得数据
+ 通过索引修改元素 changeElement,n+logn---->O(n) 

### 2.2 索引堆的优化

+ 反向查找(反向映射)reverse
+ reverse[i]表示索引i在indexes中的位置
+ indexes[i]=j,reverse[j]=i
+ indexes[reverse[i]]=i,reverse[indexex[i]]=i



***



# 和堆相关的问题

## 一、使用堆实现优先队列,动态选择优先级最高的任务执行(操作系统任务调度,游戏中自动攻击一定范围内的敌对生物)

## 二、如何在1000000个元素中选出前100名? 在N个元素中选出前M个元素:

+ 使用排序，时间复杂度为O(NlogN)
+ 使用最小堆(容量为101+1)，首先将100个数据插入最小堆，然后每插入一个新的元素后，就把堆顶的元素弹出去，保证最小堆中只有100个元素。最后，最小的都依次被弹出，只剩下前100名，(todo)
+ 使用最小堆优先队列，时间复杂度为O(NlogM)  

## 三、使用堆进行多路归并排序

+ 在原来的归并排序中，依次比较两个数进行归并
+ 若要进行多路归并，堆就可以用上了，如：一次比较四个数，四个数放入最小堆，依次弹出堆顶，弹出的堆顶是哪个子数组的元素，就从该数组选出下一个推入堆。
+ D路归并排序,D的大小来平衡性能，D越大，归并层数就越小，但每次比较的数据就会增加。
+ 如果n个元素分成n个子数组进行归并，每个子数组里面只有一个元素，其实就是堆排序了。归并排序退化成堆排序！

## 四、二叉堆和D叉堆

+ 利用二叉堆的相关定义来推导D叉堆的相关定义
+ D的大小，性能平衡视情况而定。

## 五、其他

+ 最大堆 最大索引堆 已经实现，最小堆 最小索引堆 (todo)

  ### 堆的实现细节优化

  + ShiftUp和ShiftDown中使用赋值操作替换swap操作
  + 表示堆的数组从0开始索引（todo）
  + 取消capacity的限制，动态的调整堆中数组的大小

  ### 设计最大最小队列

  + 目前我们只有最大队列和最小队列，能不能设计一种数据结构，很快的找到最大和最小
  + tips:在数据结构中，同时维护一个最大堆和一个最小堆(todo)。

  ## 其他堆

  + 二项堆(todo)
  + 斐波那契堆(todo)