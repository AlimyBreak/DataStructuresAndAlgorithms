+ [慕课网连接](https://coding.imooc.com/class/chapter/71.html)
+ 程序员的内功修炼算法数据结构

#   第五章：二叉搜索树(Binary Search Tree)
+ 二叉搜索数本质上也是也是一种二叉树，二叉树在算法中用得很多，针对不同要解决的问题类型选用对应类型的二叉树.问题导向，不是为了用数据结构而用数据结构.
+ 二叉搜索树针对查找问题(Searching Problem)拥有良好的性能.
+ 查找问题是计算机中非常重要的基础问题.



## 一.  二分查找法及其变种

### 1.1  二分查找法

+ da对于**有序数列**，才能使用二分查找法(排序的作用，排序算法是很多算法的子过程)
+ 时间复杂度logN,一直二分，其思想在1946年已经提出来，但第一个没有bug的二分查找法在1962年才出现。
+ 二分查找法-迭代方式(已经实现)
+ 二分查找法-递归方式(todo)
+ 递归方式在实现上思维会简单一些，但在性能上略差.

### 1.2 二分查找法的变种

+ **1.1**中假设数组中没有重复的元素,若有重复项，如何找到多个重复值的floor(lower bound)和ceil(upper bound)

+ floor() 返回在数组中第一次出现的位置，若没有找到就返回最后一个小于target的数所在的位置(todo)

+ ceil()返回在数组中最后一次出现的位置，若没有找到就返回最后一个大于target的数所在的位置,(todo)

  

## 二、二分搜索数

+ 二分搜索数的优势：在查找、插入和删除方面更为高效，还可以方便的得到数据之间的关系(min,max,floor,ceil,rank,select等)
+ 实现查找表(字典,key-value对)
+ 普通数组：查找元素O(n),插入元素O(n),删除元素O(n)
+ 顺序数组：查找元素O(logn),插入元素O(n),删除元素O(n)
+ 二分搜索树:查找元素O(logn),查找元素O(logn),删除元素O(logn)

### 2.1  二分搜索数的定义

+ 二分搜索数是二叉树，还应该满足：

+ 每个节点的键值大于左孩子

+ 每个节点的键值小于右孩子

+ 以左右孩子为根的子树仍然为二分搜索数

+ 二分搜索树不一定是完全二叉树，用数组表示不方便，一般是设立Node节点来管理二分搜索数

+ 实现二分查找数，BST.h

  ***

+ 插入一个新的节点：首先与根节点的值进行比较，若大于根节点的值，则一定要分配到根节点的右侧（也是一棵树），直到孩子不存在，他作为孩子，insert()。

+ 若插入的已经有了，就只更新key value信息而不生长树。

+ insert的非递归实现(todo)

  ***

+ 二分查找树的查找：子树递归查找

+ 递归实现

  ***

  二分搜索数的遍历：前序、中序和后序遍历(**深度优先遍历O(n)**，首先尝试走到最深)

+ 前序遍历：先访问当前节点，再依次递归访问左右子树;

+ 中序遍历：先递归访问左子树，再访问自身，在递归访问右子树;(**从小到大遍历**)

+ 后序遍历：先递归访问左右子树，再访问自身节点.(**释放整个二叉树时**)

  +++

+ 二分搜索树的层序遍历(**广度优先遍历O(n)**,一层一层尝试，不必优先走到最深)

+ 要引入一个队列(FIFO),根节点入队，根节点出队，根节点的孩子们一次入队，只要出就要入，直到没得入.

  ***

+ 二分搜索树 **删除节点(O(logn))**

+ 若为最大值和最小值，如何找到最大值和最小值（中序遍历的头和尾）

+ 最小值：从根节点一直往左孩子找，直到没有左孩子就是最小；最大值：从根节点一直往右孩子找，知道有没有右孩子就是最大；

+ **删除最小值节点**：根据定义，若最小值节点有右孩子，则右孩子的键值虽然大于其本身的键值但一定小于其根节点的键值，让当前节点的根节点的左孩子指针指向当前节点的右孩子，然后删除当前节点即可。（让当前节点的右孩子充当其根节点的左孩子）

+ **删除最大值节点**：根据定义，若最大值节点右左孩子，则左孩子的键值虽然小于其本身的键值但一定大于其根节点的键值，让当前节点的根节点的右孩子指针指向当前节点的左孩子，然后删除当前节点即可。（让当前节点的左孩子充电其根节点的右孩子）

+ **删除任意一个节点**(被删除的节点有两个孩子)，经典解法由Hibbard在1962年提出，又被称为Hubbard Deletion

+ 删除左右都有孩子的节点d，需要找到右子树的最小值s=min(d->right),用s取代替d.

+ 或者在d的左子树中的最大值节点来替换d，也是可以的。(todo)

  ***

+ 二分搜索树的顺序性

+ 目前都是查找表的实现，而二分搜索树具有顺序性

+ 1.minimum,maximax

+ 2.找到元素的successor和predecessor,前驱:左子树的最大值，后继：右子树的最小值(todo)

+ 3.floor,ceil(todo)

+ 4.rank：todo

+ 5.select:rank的反过程

+ 6.支持重复元素的二分搜索树

  ***

+ 二分搜索树的局限性：

+ 对于同样的数据，可以对应不同的二分搜索树，插入数据若已经有了顺序，树的高度太高使得二叉搜索树退化成链表，时间复杂度全部退化成O(n)，由于指针和递归操作过多，此时比链表还慢;

+ 优化方向：随机打乱数据插入，缺点：不能处理数据流，需要开始时就取得所有数据。

+ 优化方向：平衡二叉树,经典的一种红黑树:红色节点和黑色节点。(todo) 

+ 其他平衡二叉树：2-3tree,AVL tree,Splay tree.

+ 平衡二叉树和堆的结合:Treap.

+ Trie数据结构:查找效率很高(todo),使用trie来实现词频统计。

  ***

+ 其他树形结构和树形问题

+ 排序问题：递归法天然的树形性质：归并排序，快速排序，其实就是对排序树的遍历

+ 搜索问题：一条龙游戏，决策树的遍历，选择最优的决策；8数码问题，搜索树；8皇后互相不攻击问题，数独问题，搬运工问题(自动求解路径)。树形搜索。

+ 更多的树：KD树，区间树，哈夫曼树等等。。

  

  
  
  