+ [慕课网连接](https://coding.imooc.com/class/chapter/71.html)
+ 程序员的内功修炼算法数据结构

# 二.排序基础-选择排序
## 1.O(n<sup>2</sup>)的排序算法
### 为什么要学习O(n<sup>2</sup>)的排序算法
+ 编程简单,易于实现,是一些简单情景的首选
+ 在一些特殊情况下,简单的排序算法更有效
+ 简单的排序算法衍生出复杂的排序排序算法(希尔排序)
+ 作为子过程,改进更复杂的排序算法
## 2.选择排序(Selection Sort)
### 基本思路
+ 1.依次找到最小值与第k个值交换,在剩下的值中找最值,直到数组遍历完毕
+ 2.时间复杂度O(n<sup>2</sup>)
+ 3.编写代码,利用C++的模板函数和命名空间来支持泛型和自动生成测试用例
+ 4.编写代码,用来衡量算法的性能testSort
+ -----------------------------------------------------------------
+ 思路整理:
+ [北京大学Mooc《程序设计与算法-50.4》 https://www.icourse163.org/course/PKU-1001553023 ]
+ [a. 如果有N个元素需要排序,那么首先从N个元素来找到最小的那个(称为第0小的)放在第0个位子上的(和原来的第0个位子上的元素交换位置)]
+ [b. 然后再从剩下的(N-1)个元素中找到最小的放在第1个位子上,然后再从剩下的N-2个元素中找到最小的放在第2个位子上....
+ [c. 直到所有的元素都到位]
+ -----------------------------------------------------------------
# 三.排序基础
### 基础思路
+ 1.和插扑克牌的逻辑类似
+ 头不动,第二个和第一个比，若小于则交换;
+ 第三个和第二个比,若小于则交换,再用第二个和第一个比,若小于则交换,若出现不小于则随时停止;
+ ...
+ 2.与选择排序对比
+------------------------------------------------------------------------------------------
+ 思路整理
+ [北京大学Mooc《程序设计与算法-50.4》 https://www.icourse163.org/course/PKU-1001553023 ]
+ [a. 把整个数组a分为有序的和无序的两个部分,前者在左边,后者在右边]
+ [b. 开始有序的部分只有a[0],其余都属于无序的部分]
+ [c. 每次取出无须部分的第一个(最左边)元素,把它加入到有序部分;假设插入到合适位置p,则原p位置及其后面的有序部分元素,都向右移动一个位置,有序的部分即增加了一个元素。]
+ [d. 直到无序的部分没有元素]
+ -----------------------------------------------------------
+ 插入排序有提前结束的可能,选择排序没有提前结束的可能,理论上,面对同样的排序问题,使用插入排序比选择排序要效率高一些。
+ 为什么结果与预设不一样了? 实验结果显示:插入选择耗费的时间反而比选择排序耗费的时间多?
+ 问题出在:选择排序查找固定多的次数,但内层循环只交换一次,而插入排序的查过过程虽然可以提前结束,但结束之前每次都要交换,交换次数增加了.
+ 一次交换就是三次赋值
+ 改进方向:让内层循环只赋值减少运算量(临时)
+ 优化后
+ selectionSort : 3.984 s
+ insertionSort : 4.531 s
+ insertionSort_opt : 2.032 s
+ 特别对于近乎有序的数组进行排序,插入排序的效率明显远远高于选择排序,甚至比后续介绍的O(nlog<sup>n</sup>)还要快
+ 对近乎有序的数据进行排序,插入排序的效率很高,对于本来就有序的数组,插入排序的时间复杂度就是O(n)
+ selectionSort : 3.976 s
+ insertionSort : 4.496 s
+ insertionSort_opt : 2.281 s
+ selectionSort : 3.989 s
+ insertionSort : 0.015 s
+ insertionSort_opt : 0.016 s
# --------------------------选修内容------------------------
# 3.冒泡排序及优化(Bubble Sort)
+ ---------------------------------------------------------------
+ 基本思路:依次比较相邻两个数据的大小,若前者大于后者,则交换
+ n个数据需要进行n-1轮冒泡(n-1个的冒出去,最后一个自然拍出来了)
+ 第i(i=1,2,...,n-1)轮冒泡需要比较(n-i)次(j=0,1,2,3,...,n-i-1)
+ ----------------------------------------------------------------
+ 思路整理
+ [北京大学Mooc《程序设计与算法-51.5》 https://www.icourse163.org/course/PKU-1001553023 ]
+ [ a. 将整个数组a分为有序的部分和无序的两个部分,有序的在右边,无序的在左边]
+ [ b. 开始整个数组都是无序的,有序的部分没有元素]
+ [ c. 每次都要使得无序部分的最大的元素移动到有序部分第一个元素的左边.移动的方法是:依次比较相邻的两个元素,如果前面的比后面的大,就交换他们的位置]
+ [ d. 这样,大的元素就像水里气泡一样的不断往上浮.一次移动结束有序部分增加了一个元素.持续移动,直到无序的部分没有元素]
+ ---------------------------------------------------------------
+ 冒泡排序的优化思路:没看懂作者的写法= =.暂时搁置
+ ---------------------------------------------------------------
# 4.希尔排序(Shell sort)
+ 希尔排序是插入排序的延伸,排序复杂度比较麻烦
+ = =.暂时搁置
