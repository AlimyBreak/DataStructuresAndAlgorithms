+ [慕课网连接](https://coding.imooc.com/class/chapter/71.html)
+ 程序员的内功修炼算法数据结构

# 第四章:堆和堆排序
## 一.堆排序(Heap Sort)
+ 这章的内容主要是堆,一种全新的数据结构,排序只是堆这种数据结构引申出来的一个应用而已.
### 1.1 堆和优先队列(Heap and Priority Queue)
+ 普通队列:先进先出,后进后出,由入队的时间顺序来确定出队的顺序.
+ 优先队列:出队顺序与入队顺序无关,和优先级有关
+ 应用场景: 医院看病,急诊优先;操作系统执行任务,任务优先级高的优先获得CPU控制权
+ "动态选择优先级最高的任务执行",关键在动态,而频繁使用排序将耗费大量的时间.
+ 这时就要用到优先队列了.
+ 其他问题: 在100万个元素中如何选出前100名? 在N个元素中选出前M个元素.
+ 排序解决: O(NlogN)
+ 优先队列解决:O(NlogM)
+ 如何做到? 本章讲解.
+ 优先队列的主要操作: 入队 出队(取出优先级最高的元素)
+ 优先队列的实现:
+ 普通数组实现: 入队 O(1),出队 O(n)
+ 顺序数组实现: 入队 O(n),出队 O(1)
+ 堆实现:       入队 O(lgn),出队 O(lgn)
+ ????没懂 顺序数组和普通数组有啥区别
+ 使用堆实现优先队列:对于总共N个请求,使用普通数组或顺序数组,最差情况O(N<sup>2</sup>),而使用堆稳定在O(NlgN)级别.
### 1.2 堆的实现(基本存储)
#### 1.2.1 二叉堆(Binary Heap)
+ 性质1:二叉树,一个父节点最多可以有两个子节点,且子节点的数据都不大于父节点(大根堆)
+ 性质2:二叉堆总是一颗完全二叉树(除最后一层外,其他层都必须铺满元素,且最后一层的元素都必须依次排满左侧)
+ 完全二叉树的定义:若设二叉树的深度为h,除第h层外，其它各层(1~h-1)的结点数都达到最大个数,第h层所有的结点都连续集中在最左边,这就是完全二叉树.
+ 小根堆的定义只要修改性质1即可,本文中只考虑大根堆.
##### 1.2.2 用数组来实现一个二叉堆

- (画图)给完全二叉树的元素从上往下,从左往右进行编号 1 2~3 4~7
- 若从1开始编号:
- 对于每一个节点,如果他有左孩子,左孩子的序号一定是父亲节点序号的2倍;
- 对于每一个节点,如果他有右孩子,右孩子的序号一定是父亲节点序号的2倍加1.
- 若从0开始编号:
- 对于每一个节点,如果他有左孩子,左孩子的序号一定是父亲节点序号的2倍加1;
- 对于每一个节点,如果他有右孩子,右孩子的序号一定是父亲节点序号的2倍加2.
- 编程实现:MaxHeap.h,插入元素,打印二叉堆(直接拷贝了),[原始代码链接](https://github.com/liuyubobobo/Play-with-Algorithms/blob/master/04-Heap/Course%20Code%20(C%2B%2B)/03-Shift-Up/main.cpp)
- 核心操作:Shift_up,插入一个新的元素到堆，一个元素插入到一个现成的二叉堆(已经满足最大堆或最小堆的定义)，只要依次和父节点比较看是否需要交换即可，交换以后不需要和原父节点的另外一个孩子比较，原来的父亲节点就比另外一个孩子大，比父亲节点大才交换，交换上去的一定比另外一个孩子大。
- 核心操作:Shift_Down,每次只能取出堆顶的元素,然后将最后一个和第一个交换，计数减一，根节点和两个孩子节点中的较大者进行比较，若孩子节点更大就交换，依次递推。
- shift_up 和 shift_down 的优化(todo)

##### 1.2.3 堆排序算法

+ heapSort1:先逐一插入，再逐一取出
+ Heapify优化:先按数组排好，然后逐一从尾到头的考察非叶子节点，逐一shiftdown(子树逐一满足最大根的性质).
+ 完全二叉树的性质：最大标号的叶子非叶子节点（count/2, 取整的除法,count从1开始计数，是当前二叉树点的个数）
+ MaxHeap_Array新建一个构造函数，在构造堆的时候就做heapify
+ 测试结果：按道理heapify应该比逐一插入快(我的实验结果貌似不是这样),堆排序慢于快速排序和归并排序，在系统级别很少使用堆排序，堆排序主要用于动态数据的维护。
+ 为啥Heapify比逐一插入要快？将n个元素逐一插到一个空堆中，算法复杂度是O(nlogn),而Heapify的过程算法复杂度是O(n). 推导过程略.

##### 1.2.4 原地堆排序(从0开始索引)

+ 把原始数组数据分为两部分，一部分为堆部分，一部分为排序好的部分，起始时，堆部分是原始数据数组，排序好的部分元素个数为0.

+ 首先对原始堆部分进行Heapify，完成后交换第一个和堆部分最后一个元素，然后堆部分数据个数减1，排序好的部分元素个数加1，然后对堆的首个元素进行shiftdown.

+ 重复上述步骤中的数据交换和shiftdown，直到乱序堆部分的元素个数为1，这样原始数据数组就是排序好的数组。

+ 空间复杂度O(1),时间复杂度

+ 测试结果：

  ```C
  /*
  Random Array: size = 50000,range [ 0 ~50000]
  SelectionSort : 4.111 s
  BubbleSort : 16.295 s
  insertionSort : 8.711 s
  mergeSort : 0.014 s
  heapSort1 : 0.025 s
  heapSort2 : 0.022 s
  heapSort3 : 0.021 s
  quickSort3ways : 0.018 s
   Random Array: size = 50000,NearlyOrdered [ 0 ~ 50000],swap_times :30
  SelectionSort : 4.201 s
  BubbleSort : 3.847 s
  insertionSort : 0.01 s
  mergeSort : 0.002 s
  heapSort1 : 0.023 s
  heapSort2 : 0.016 s
  heapSort3 : 0.016 s
  quickSort3ways : 0.015 s
   Random Array: size = 50000,range [ 0 ~10]
  SelectionSort : 4.258 s
  BubbleSort : 15.397 s
  insertionSort : 7.642 s
  mergeSort : 0 s
  heapSort1 : 0.031 s
  heapSort2 : 0.016 s
  heapSort3 : 0.015 s
  quickSort3ways : 0 s
  */
  ```

  

